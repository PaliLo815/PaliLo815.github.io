---
title: Introduction to 3D Programming with DirectX12 (chapter 8)
tags:
- 공부
---

**목표**

1. 빛과 재질 사이의 기본적인 상호작용을 이해한다.
2. 국소(지역) 조명과 전역 조명의 차이를 이해한다.
3. 표면의 한 점이 "면한" 방향을 수학적으로 서술하는 방법과 그것을 이용해서 입사광이 표면을 때리는 각도를 구하는 방법을 파악한다.
4. 법선 벡터를 제대로 변환하는 방법을 배운다.
5. 주변광, 분산광, 반영광을 구분한다.
6. 지향광, 점광, 점적광을 구현하는 방법을 배운다.
7. 감쇠 매개변수들을 제어함으로써 빛의 세기를 깊이의 함수로서 변화시키는 방법을 이해한다.

## 8.1 빛과 재질의 상호작용

조명이 없을 때는 정점들의 색상을 응용 프로그램이 직접 저장했지만, 조명을 사용하면 직접 저장하지 않는다. 표면의 재질과 빛의 상호작용에 기초해서 정점의 색이 결정되기 때문이다.

재질<sup>**material**</sup>은 빛과의 상호작용 방식을 결정하는 속성들의 집합이라 할 수 있다. 반사, 흡수하는 빛의 종류, 굴절률, 투명도 등이 있다. 재질 속성을 적절하게 지정함으로써 현실에 존재하는 다양한 표면(유리, 금속, 나무, 물 등)을 흉내낼 수 있다.

하나의 광원은 빨간색, 초록색, 파란색의 빛을 여러 가지 세기<sup>**intensity**</sup>로 방출한다. 이 빛이 물체와 충돌하면 일부는 흡수되고 일부는 반사된다(유리 같은 투명한 물체의 경우 빛의 일부가 매질을 통과하지만 이번 장에서는 고려하지 않는다). 우리 눈은 이렇게 반사된 빛의 RGB 세기를 물체의 색으로 인식한다.

대부분의 실시가 응용 프로그램은 국소 조형 모형<sup>**local illumination model**</sup>을 사용한다. 국소 조형 모형은 각 물체를 독립적으로 처리하며, 오직 광원에서 직접 방출된 빛만 다룬다. 광원과 물체 사이를 벽이 막고 있는 모습을 상상해보자. 현실적으로 물체는 빛을 받아선 안되지만, 국소 조형 모형에서는 벽과 물체에 모두 빛이 가해진다.

위의 문제를 해결하는 것이 전역 조명 모형<sup>**global illumination model**</sup>이다. 이것은 광원뿐만 아니라 다른 물체에 반사된 간접광도 고려한다. 거의 실사적인 장면을 만들어 낼 수 있지만 실시간 게임에 사용하기에는 비용이 너무 크다.

## 8.2 법선 벡터

면 법선<sup>**face normal**</sup>은 다각형이 면한 방향을 나타내는 단위 벡터다.

표면 법선<sup>**surface normal**</sup>은 포면의 한 점의 접평면<sup>**targent plane**</sup>에 수직인 단위벡터다.

삼각형과 구에서 법선 벡터를 찾는다고 생각해보자. 삼각형은 단 하나의 면 법선이 나오고, 구는 무한히 많은 표면 법선을 가지고 있다.

조명 계산을 위해 삼각형 메시의 모든 표면에서 표면 법선이 필요하다. 그런데 단 하나의 삼각형에 대해서만 표면 법선을 가지고 있어도 된다. 나머지 모든 법선을 계산을 통해 얻을 수 있기 때문이다.

정점에 지정한 표면 법선을 흔히 정점 법선<sup>**vertex normal**</sup>이라 부른다.

법선의 보간과 조명 계산을 픽셀마다 수행하는 것을 픽셀별 조명<sup>**per pixel lightning**</sup> 또는 퐁 조명<sup>**Phong lightning**</sup>이라 한다. 조명을 정점마다 계산할 수도 있는데, 픽셀별 조명보다 덜 정확하지만 비용이 싸다. 정점별 조명 계산은 vertex shader에서 수행한다. rasterization 단계는 vertex shader에서의 결과를 삼각형 표면에 따라 보간해서 각 픽셀의 조명 값을 결정한다. pixel shader의 계산을 vertex shader로 옮기는 것은 품질을 희생해서 성능을 높이는 흔한 최적화 기법 중 하나다.
{:.info}

##### 법선 벡터 계산

삼각형 $\triangle p_0p_1p_2$의 면 법선 벡터 $n$은 아래처럼 구할 수 있다.

$$
\begin{align}
u & = p_1 - p_0 \\
v & = p_2 - p_0 \\
n & = \frac{u \times v}{\| u \times v \|} \\
\end{align}
$$

다각형 메시의 정점 법선을 구할 때는 정점 법선 평균 기법<sup>**vertex normal averaging**</sup>을 사용한다. 예를들어 삼각형 4개로 이루어진 다각형 메시의 정점 법선은 아래와 같다.

$$n_{avg} = \frac{n_0+n_1+n_2+n_3}{\|n_0+n_1+n_2+n_3\|}$$

단순히 네 개의 면 법선을 구해서 4로 나눈게 아니란 점에 주목하자. 물론 이것은 정확한 값이 아니다. 더 정교한 방법도 존재한다. 예를 들어 다각형의 면적에 따라 가중치를 달리한 가중 평균 기법을 사용할 수도 있다.

##### 정점 법선을 구하는 예시 코드

```cpp
for (int i = 0; i < num_triangle; ++i) {
    const size_t i0 = indices[3 * i + 0];
    const size_t i1 = indices[3 * i + 1];
    const size_t i2 = indices[3 * i + 2];

    Vertex& v0 = vertices[i0];
    Vertex& v1 = vertices[i1];
    Vertex& v2 = vertices[i2];

    const Vector3 faceNormal = v0.cross(v1, v2);
    v0.normal += faceNormal;
    v1.normal += faceNormal;
    v2.normal += faceNormal;
    }
for (Vertex& vertex : vertices) {
    vertex.normal.normalize();
}
```