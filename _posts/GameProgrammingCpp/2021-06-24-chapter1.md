---
title: Game Programming in C++ (chapter 1)
tags:
- 공부
---

## 기초 2D 그래픽스

오늘날 사용되는 대부분의 디스플레이는 래스터 그래픽스(raster graphics). 픽셀들의 색상과 세기를 이용해 표현한다. 해상도는 이 픽셀의 수. 예를들어 1080p(1920 * 1080) 해상도는 픽셀이 1920 * 1080개 있다. 픽셀은 색상 표현을 위한 RGB에 투명도 표현을 위한 alpha를 더해 RGBA값으로 표현

#### 색상 버퍼(Color Buffer)

각 인덱스가 화면상의 픽셀과 일치하는 2차원 배열. R, G, B, A에 각각 8비트씩 할당하면 픽셀 하나는 int와 같은 32비트 자료형이고, 1080p 해상도에 대한 Color Buffer의 크기는 약 7.9MB(4 * 1920 * 1080)

**Color Buffer vs 프레임 버퍼(Frame Buffer)** \\
Frame Buffer의 정확한 정의는 Color Buffer와 기타 버퍼(깊이 버퍼, 스텐실 버퍼)의 조합이다. 좀 더 포괄적인 개념.
{:.info}

최신 게임은 R, G, B, A에 16비트씩 할당하기도 한다. RGBA값을 표현하는 방법은 두 가지다.

1. 8비트에 맞춰서 0 ~ 255의 값으로 표현 
2. 0.0f ~ 1.0f 범위의 값으로 정규화

2번 방법은 RGBA값에 몇 비트인지 상관없이 동작한다. 1번 방법은 원치 않은 결과를 얻을 수 있다. 8비트에서 빨간색은 (255, 0, 0)이지만 16비트에서 (255, 0, 0)은 거의 검정색이다.

#### 더블 버퍼링(Double Buffering)

게임이 Color Buffer에 데이터를 쓰고 디스플레이가 같은 Color buffer를 읽는다고 하자. 데이터 쓰기 -> 읽기 -> 쓰기 -> 읽기가 순서대로 동작하지 않을 수 있다. 이를테면 화면에 A를 출력하고 B를 출력해야 하는데, 게임이 B를 Color Buffer에 미처 다 쓰지 못했는데 디스플레이가 이를 읽어간다면 화면엔 위는 B고 아래는 A인 괴상한 문자가 출력될 것이다. 이걸 스크린 테어링(Screen Tearing)이라 한다.

Screen Tearing을 제거하려면 두 가지가 필요하다.

1. Color Buffer 두 개를 교대로 사용한다. 디스플레이는 전면 버퍼(Front Buffer)를 읽어가고, 게임은 후면 버퍼(Back Buffer)에 데이터를 저장한다. 프레임이 완료되면 둘은 Buffer를 교환한다. 두 개의 Buffer를 번갈아 사용하므로 더블 버퍼링(Double Buffering)이라 부른다.
2. Double Buffering이어도 게임이 어느 Buffer를 쓰려고 하는데, 디스플레이가 여전히 그 Buffer를 그리는 중이라면 여전히 충돌이 발생한다. 이 상황은 게임이 너무 빨리 업데이트 되는 경우에만 일어난다. 해결책은 게임이 디스플레이가 다 그릴 때까지 기다리는 것이다. 이를 수직 동기화(Vertical Synchronization) 또는 vsync라 부른다.

Vertical Synchronization를 사용하면 게임이 짧은 시간 대기를 하면서 정확하게 30 또는 60FPS를 맞추지 못 할 수도 있다. 많은 게임이 수직 동기화 옵션을 제공하는 이유.

최근에는 적응적 화면 재생 빈도(Adaptive Refresh Rate) 기술이 등장. 디스플레이가 화면을 갱신할 때 게임에게 알려주는 것이 아니라 역으로 게임이 디스플레이를 언제 갱신해야 하는지 알려준다. Screen Tearing과 프레임 저하를 동시에 해결.

FPS(Frame Per Second)는 초당 화면을 얼마나 갱신하는지 나타낸다. 
